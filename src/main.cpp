#include <string>#include <stdio.h>#include <iostream>#include "mkl.h"#include "mkl_types.h"using namespace std;int main(){	/* Declaration of staitc pointers*/	static float* values_A = NULL;	static float* values_B = NULL;	static float* values_C = NULL;	static MKL_INT* columns_A = NULL;	static MKL_INT* columns_B = NULL;	static MKL_INT* columns_C = NULL;	static MKL_INT* rowIndex_A = NULL;	static MKL_INT* rowIndex_B = NULL;	static MKL_INT* pointerB_C = NULL;	static MKL_INT* pointerE_C = NULL;	static sparse_matrix_t csrA = NULL;	static sparse_matrix_t csrB = NULL;	static sparse_matrix_t csrc=NULL;	static int nNonZero_A = 0;	static int nNonZero_B = 0;	static MKL_INT* indxB = NULL;	static MKL_INT* indyB = NULL;	static int MAT_A_N_ROWS = 10;	static int MAT_A_N_COLS = 10;	/* Declaration of values*/	float	val;	int indexA = 0,			indexB = 0,			i = 0,			iCol = 0,			iRow = 0,			inx = 0;	MKL_INT rows,			cols;	int status;	sparse_status_t sparse_status;	sparse_index_base_t	indexing = SPARSE_INDEX_BASE_ZERO;	clock_t start, end;	double cpu_time_used;	//struct matrix_descr    descr_type_gen;	start = clock();	if (csrA == NULL)	{		/*count matrix A non zero values*/		printf("*****Matrix A*****\n");		for (iRow = 0; iRow < MAT_A_N_ROWS; iRow++)		{			for (iCol = 0; iCol < MAT_A_N_COLS; iCol++)			{				if (pMatrixA[iRow * MAT_A_N_COLS + iCol] != 0.0f)				{					nNonZero_A++;				}				//printf("%f ", pMatrixA[k * SRC1_N_COLS + j]);			}			//printf("\n");		}		/*allocating memory for csr representation*/		if (nNonZero_A > 0)		{			values_A = (float*)malloc(sizeof(float) * nNonZero_A);			columns_A = (MKL_INT*)malloc(sizeof(MKL_INT) * nNonZero_A);		}		rowIndex_A = (MKL_INT*)malloc(sizeof(MKL_INT) * (MAT_A_N_ROWS + 1));		/*Matrix A in csr format*/		for (iRow = 0; iRow < MAT_A_N_ROWS; iRow++)		{			rowIndex_A[iRow] = indexA;			for (iCol = 0; iCol < MAT_A_N_COLS; iCol++)			{				val = pMatrixA[iRow * MAT_A_N_COLS + iCol];				if (val != 0.0f)				{					values_A[indexA] = val;					columns_A[indexA] = iCol;					indexA += 1;				}			}		}		rowIndex_A[iRow] = indexA;		printf("Number of non zero values of Matrix A is: %d\n", nNonZero_A);		/*CSR handle creation*/		sparse_status = mkl_sparse_s_create_csr(&csrA,				// CSR Handler				indexing,				// Zero Index				MAT_A_N_ROWS,			// numer of rows				MAT_A_N_COLS,			// number of cols				rowIndex_A,				// first non-zero element in a row j of A				rowIndex_A + 1,			// last non-zero element in a row j of A				columns_A,				// Colunm Index				values_A);			// array that contains the non-zero elements of A	}	if (csrB == NULL)	{		/*count matrix B non zero values*/		printf("*****Matrix B*****\n");		for (iRow = 0; iRow < MAT_B_N_ROWS; iRow++)		{			for (iCol = 0; iCol < MAT_B_N_COLS; iCol++)			{				if (pMatrixB[iRow * MAT_B_N_COLS + iCol] != 0.0f)				{					nNonZero_B++;				}				//printf("%f ", pMatrixA[k * SRC1_N_COLS + j]);			}			//printf("\n");		}		if (nNonZero_B > 0)		{			values_B = (float*)malloc(sizeof(float) * nNonZero_B);			columns_B = (MKL_INT*)malloc(sizeof(MKL_INT) * nNonZero_B);			indxB = (MKL_INT*)malloc(sizeof(MKL_INT) * nNonZero_B);			indyB = (MKL_INT*)malloc(sizeof(MKL_INT) * nNonZero_B);		}		rowIndex_B = (MKL_INT*)malloc(sizeof(MKL_INT) * (MAT_B_N_ROWS + 1));		/*Matrix B in csr format*/		for (iRow = 0; iRow < MAT_B_N_ROWS; iRow++)		{			rowIndex_B[iRow] = indexB;			for (iCol = 0; iCol < MAT_B_N_COLS; iCol++)			{				val = pMatrixB[iRow * MAT_B_N_COLS + iCol];				if (val != 0.0f)				{					indxB[indexB] = iCol;					indyB[indexB] = iRow;					values_B[indexB] = val;					columns_B[indexB] = iCol;					indexB += 1;				}			}		}		rowIndex_B[iRow] = indexB;		printf("Number of non zero values of Matrix B is: %d\n", nNonZero_B);		sparse_status = mkl_sparse_s_create_csr(&csrB,				indexing,				MAT_B_N_ROWS,				MAT_B_N_COLS,				rowIndex_B,				rowIndex_B + 1,				columns_B,				values_B);		if (sparse_status)		{			printf("mkl_sparse_s_create_csr(&csrB, ...) - sparse_status is: %d\n", sparse_status);		}	}	else	{		sparse_status = mkl_sparse_s_update_values(csrB, nNonZero_B, indxB, indyB, values_B);	}	//Actual Multiplication - Documentation in MKL.pdf - Line 327	status = mkl_sparse_spmm(SPARSE_OPERATION_NON_TRANSPOSE, csrA, csrB, &csrC);	/*converting the result from internal representation to CSR */	mkl_sparse_s_export_csr(csrC, &indexing, &rows, &cols, &pointerB_C, &pointerE_C, &columns_C, &values_C);	end = clock();	cpu_time_used = ((double)(end - start)) / CLOCKS_PER_SEC;	return cpu_time_used;}//// Created by Isuru Ranawaka on 1/7/23.//